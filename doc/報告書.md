原因とポイント（結論）
- graph_engine.query(...) は「自然文→Cypher自動生成→DB実行→要約」の黒箱プロセスです。プロンプト内にCypherを書いても、そのCypherを実行してくれる保証はありません（多くの場合“指示文”として扱われます）。
- 今回のスキーマでは `parameters/return_value` は `Function` 直下でなく関連ノード（`Parameter`/`Type`）に分離。LLMが正しいCypherを自動生成できないと空応答になります。
- したがって「確実にCypherを実行したい」なら、graph_engine.query に頼らず、明示的に Neo4j ドライバで実行するか、Cypher専用エンジン（利用可なら as_cypher_query_engine など）を使うのが安全です。

現状でできる実践策
- 最小の改善（プロンプト最適化）
  - graph_engine.query へ渡す文は「実行してほしいCypherの要件」を日本語ではなく簡潔な英語で、対象ラベル・プロパティ・リレーションを明示し、曖昧表現を避ける。
  - “Execute this Cypher … Only return results as JSON.” のように出力形式と制約を強調（説明文が混じるのを避ける）。
- 失敗時の安定策（既に実装済のフォールバックを強化）
  - いま追加したフォールバックCypher（HAS_PARAMETER/RETURNS を辿る）で `parameters/return_value` を組み立てて返すのは正しい方向です。グラフ側の答えが安定して取れるので、統合回答に使えます。
- さらなる堅牢化（推奨）
  - graph_engine の代わりに、明示 Cypher実行関数を使う（Neo4j ドライバで実行）。クエリ文字列はすでに main_0905.py にあるフォールバックを流用可能。
  - LlamaIndexのバージョンが対応していれば「Cypher特化のQueryEngine」（例: as_cypher_query_engine）に切り替え。なければ現状の「プロンプト最適化＋直接Cypher実行」のハイブリッドを継続。

チェックリスト
- Function/Parameter/Type の関係が正しく張られているか（HAS_PARAMETER, RETURNS）。
- `Parameter.parent_function` の文字列と `Function.name` の対応がブレていないか（大小・表記ゆれ）。
- LLMモデル設定（温度0、冗長出力抑制、英語短文プロンプト）で一貫性が出ているか。

要点
- graph_engine.query は“自然文→Cypher自動生成”で不確実性がある。
- 今回は明示Cypher実行ルート（フォールバック）を強化済みなので、回答は安定化できる。
- さらに安定を求めるなら、graph_engine.query の結果をあくまで補助とし、最終結果は「直接Cypher結果＋ベクトル結果の統合」で作るのが現実的です。