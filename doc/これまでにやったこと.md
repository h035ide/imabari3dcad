# GPT-5に関する情報

## Chatgptにおいて
画像をもとに説明

## モデル
|旧モデル|GPT‑5 モデル|APIエイリアス|
|:---|:---|:---|
|GPT‑4o|gpt-5-main|GPT-5 Chat|
|GPT‑4o-mini|gpt-5-main-mini||
|OpenAI o3|gpt-5-thinking|GPT-5|
|OpenAI o4-mini|gpt-5-thinking-mini|GPT-5 mini|
|GPT‑4.1-nano|gpt-5-thinking-nano|GPT-5 nano|
|OpenAI o3 Pro|gpt-5-thinking-pro||

## 使用可能なパラメータ設定
### 推論努力（Effort）
- Minimal（最小）：指示に正確。コーディングなどに向いているが、追加の指示が必要なケースも
- Low（低）：軽い思考で迅速な応答
- Medium（中）：デフォルト設定、バランスの取れたパフォーマンス
- High（高）：複雑な問題に対する深い推論

### 冗長性（Verbosity）
モデルが生成する出力の長さを調整する設定
APIやプロンプトで調整可能
- Low（低）：簡潔な回答や短いコードに最適
- Medium（中）：バランスの取れた出力
- High（高）：詳細な説明や構造化されたコード


# RAGの基本方針

## RAG（Retrieval-Augmented Generation）とは
RAGは、大規模な知識ベースから関連情報を検索し、その情報をLLMの生成に活用する手法です。本研究では2つのデータベース技術を組み合わせてRAGシステムを構築します。

## アプローチ1：ベクトルDB（意味的類似性検索）

### 基本概念
ベクトルDBは、テキストや画像を数値ベクトルに変換して格納し、**意味的に似ている**コンテンツを効率的に検索します。

### 特徴と利点
- ✅ **高速な類似検索**: 意味的に近い情報を瞬時に発見
- ✅ **多様なデータ対応**: テキスト、画像、音声など
- ✅ **実装の簡単さ**: 既存のライブラリで容易に構築可能

### 代表的なツール
- **Chroma**: 軽量で使いやすいベクトルDB
- **FAISS**: Meta開発の高性能検索ライブラリ

### 本研究での活用例
```
ユーザー質問: "船体の強度計算について"
ベクトル検索 → 類似した強度計算コード・ドキュメントを取得
```

## アプローチ2：GraphDB（関係性ベース検索）

### 基本概念
GraphDBは、データ間の**関係性**に注目し、ノード（データ）とエッジ（関係）でネットワーク構造を表現します。

### GraphRAGの特徴
GraphRAGは従来のベクトル検索に加え、データ間の複雑な関係性も考慮した検索・生成を行います。

#### メリット
- ✅ **関係性の理解**: 「AがBに依存し、BがCに影響する」といった複雑な関係を把握
- ✅ **推論能力向上**: 間接的な関係からも有用な情報を導出
- ✅ **文脈の深い理解**: 単語の類似性だけでなく概念間の関係を活用

#### デメリット
- ❌ **実装の複雑さ**: グラフ構造の設計が困難
- ❌ **計算コスト**: ベクトル検索より処理が重い
- ❌ **データ構築コスト**: 関係性の定義に時間が必要

### 本研究での活用例
```
関数A → 関数B → 関数C の依存関係を理解
「関数Aを修正すると、関数Cにどう影響するか？」
→ GraphDBで依存関係を辿り、影響範囲を特定
```

## 統合アプローチ：ハイブリッドRAG

### なぜ併用するのか
単一の手法では限界があるため、**ベクトルDBとGraphDBの併用**が最適解です。

### 統合システムの動作フロー
```
1. ベクトルDB: 意味的に類似したコードを高速検索
2. GraphDB: 検索結果の関係性・依存関係を分析
3. LLM: 両方の情報を統合して精度の高い回答を生成
```


# APIドキュメントのデータベース化
２つのアプローチから検討を進めた
## 1つめのアプローチ：ドキュメントをLLMで解釈

### doc_paserシステムの概要
`doc_paser`システムは、EVO.SHIP APIの自然言語ドキュメントをLLMで解析し、構造化されたJSONデータに変換してNeo4jグラフデータベースに格納するシステムです。

### システム構成
1. **doc_paser.py** - メインの解析エンジン
   - GPT-5モデル（gpt-5-mini）を使用
   - GPT-5の推論努力パラメータ活用（high設定）
   - 自己修正エージェント機能を搭載
   - 型定義とAPI関数の構造化解析
   - LangGraphを使用したワークフロー制御

2. **neo4j_importer.py** - グラフデータベース構築
   - 解析結果をNeo4jに自動インポート
   - 関数間の依存関係（FEEDS_INTO関係）を自動生成
   - オブジェクト指向設計によるモジュラー構造

3. **サポートツール群**
   - `clear_database.py` - データベース完全クリア
   - `cleanup_duplicates.py` - 重複関係のクリーンアップ
   - `doc_paser_tests/` - テストスイート（コード生成・検証）

### Neo4jグラフモデル
- **ノードタイプ**：
  - `Function` - API関数
  - `ObjectDefinition` - パラメータオブジェクト
  - `Parameter` - 関数・オブジェクトの引数
  - `Type` - データ型定義

- **関係タイプ**：
  - `HAS_PARAMETER` - 関数とパラメータの関係
  - `HAS_PROPERTY` - オブジェクトとプロパティの関係
  - `HAS_TYPE` - パラメータと型の関係
  - `RETURNS` - 関数の戻り値
  - `FEEDS_INTO` - 関数間依存関係（ビルダーパターン）

### 自己修正機能
LangGraphを活用した高度な品質管理：
- コード品質分析（型ヒント、ドキュメント文字列の検証）
- 自動修正生成（LLMベース）
- 反復的改善プロセス（最大修正回数・品質閾値設定可能）

### プロンプトエンジニアリング
- XML構造化プロンプト（`prompt.xml`）
- 厳密な出力形式指定（JSON Schema準拠）
- 段階的解析ワークフロー

## 結論
LLMを使用するとLLMならではの解釈を付け加えることができる
しかし、ハルシネーションや決定論的解釈に欠ける
確実性が高いのはスクリプトで変換する方だ

# pythonコードの解析
プログラムを書くうえで実際に用いられているコードをモデルにする

## システムの全体像
`code_parser`システムは、既存のPythonコードを構文解析し、知識グラフとして構造化することで、コード生成AIのための学習データベースを構築します。

### アーキテクチャ概要
```
Tree-sitter構文解析 → Neo4jグラフDB格納 → LLM分析統合 → ベクトル検索 → RAG統合
```

### システム構成要素

1. **core/** - 基盤機能
   - `parse_code.py` - メインエントリーポイント
   - `analysis_schemas.py` - データ構造定義
   - `code_extractor.py` - コード抽出ロジック
   - `simple_utils.py` - ユーティリティ関数

2. **integration/** - 統合機能
   - `main_integrated.py` - 統合パーサーシステム
   - `enhanced_llm_analyzer.py` - LLM分析エンジン
   - `llm_analysis_utils.py` - 分析ユーティリティ

3. **storage/** - データ永続化
   - ベクトルデータベース統合
   - Neo4jグラフDB操作

4. **performance/** - パフォーマンス最適化
   - ベンチマーク機能
   - 分析速度最適化

## tree-sitterの役割

### 高精度構文解析エンジン
Tree-sitterは、Pythonコードの構文を詳細に解析する役割を担います：

- **リアルタイム構文解析**: エラー耐性のある高速解析
- **増分解析**: コード変更部分のみの効率的な再解析
- **詳細な構文木生成**: AST（抽象構文木）の生成

### 抽出される構文要素
以下の構文要素を自動識別・抽出：

#### ノードタイプ
- `Module` - Pythonモジュール全体
- `Class` - クラス定義（メソッド、属性含む）
- `Function` - 関数定義（引数、戻り値含む）
- `Variable` - 変数定義と使用
- `Parameter` - 関数・メソッドパラメータ
- `Import` - インポート文
- `Call` - 関数/メソッド呼び出し
- `Assignment` - 代入操作
- `Attribute` - 属性アクセス

#### 関係タイプ
- `CONTAINS` - 包含関係（モジュール内クラス等）
- `CALLS` - 関数呼び出し関係
- `USES` - 変数使用関係
- `IMPORTS` - インポート関係
- `HAS_PARAMETER` - パラメータ所有関係
- `ASSIGNS` - 代入関係

### Neo4jグラフモデル設計
```cypher
# 高複雑性関数の検索
MATCH (f:Function)
WHERE f.complexity_score >= 5
RETURN f.name, f.complexity_score, f.file_path
ORDER BY f.complexity_score DESC

# 関数間依存関係の追跡
MATCH (caller:Function)-[:CALLS]->(called:Function)
WHERE caller.name = "main"
RETURN caller.name, called.name
```

## LLM統合による高度な分析

### 多層分析アプローチ
1. **構造分析**: Tree-sitterによる構文構造の抽出
2. **意味分析**: LLMによるコード意図の理解
3. **品質分析**: 複雑性・保守性の評価
4. **パターン分析**: 設計パターンの自動識別

### EnhancedLLMAnalyzer
- GPT-4/GPT-5による高度なコード理解
- 関数の目的・機能の自然言語説明生成
- 設計パターンの自動識別
- リファクタリング提案の生成

## 統合テストシステム

### run_tests.py による包括的テスト
- **ユニットテスト**: 個別機能の動作確認
- **統合テスト**: システム全体の連携確認
- **カバレッジテスト**: コードカバレッジの測定
- **パフォーマンステスト**: 処理速度の監視

### 品質保証機能
- 自動化されたCI/CDパイプライン
- コード品質メトリクスの継続監視
- エラー検出・修正機能


# エージェントシステム

# FreeCADMCP

## 概要
LLMからのツール呼び出しによるCAD操作の可能性について、FreeCADMCPの実装を参考に検討します。本研究では直接MCPを使用しませんが、LLMとCADソフトウェアの連携手法として参考になる設計パターンが含まれています。

## LLMツール呼び出しのアプローチ

### 基本的なアーキテクチャ概念
```
LLM (GPT-5) → Function Calling → CAD API → 3Dモデル生成
```

FreeCADMCPから学べる設計パターン：
1. **ツール関数の抽象化**: 複雑なCAD操作を単純な関数として定義
2. **パラメータ化**: 自然言語から構造化されたパラメータへの変換
3. **視覚フィードバック**: 生成結果の確認と反復改善

## Tools定義による機能拡張

### 基本操作Tools
FreeCADMCPでは以下のtoolsを定義してCAD操作を抽象化：

#### ドキュメント管理
- `create_document`: 新しいFreeCADドキュメントの作成
- `get_objects`: ドキュメント内全オブジェクトの取得
- `get_object`: 特定オブジェクトの詳細情報取得

#### オブジェクト操作
- `create_object`: 新しい3Dオブジェクトの作成
- `edit_object`: 既存オブジェクトの編集・変更
- `delete_object`: オブジェクトの削除

#### 高度な機能
- `execute_code`: 任意のPythonコードをFreeCAD内で実行
- `insert_part_from_library`: パーツライブラリからの部品挿入
- `get_parts_list`: 利用可能パーツの一覧取得

#### 視覚フィードバック
- `get_view`: アクティブビューのスクリーンショット取得

## 本研究への応用可能性

### 1. Function Callingによる直接統合
```python
# 例：EVO.SHIPへの応用
def create_evoship_component(component_type: str, parameters: dict):
    """LLMから呼び出し可能なEVO.SHIP関数"""
    # 自然言語パラメータをEVO.SHIP APIに変換
    # 3Dモデル生成
    # 結果の返却
```

### 2. ツール関数の設計パターン
```python
# 参考：FreeCADMCPのツール設計
tools = [
    "create_object",      # → create_evoship_hull
    "edit_object",        # → modify_ship_structure  
    "get_view",          # → get_model_preview
    "execute_code"       # → execute_evoship_script
]
```

### 3. パラメータ抽象化の手法
- 自然言語仕様 → 構造化パラメータ
- 工学的制約の自動考慮
- デフォルト値による補完

## 実用例

### フランジ設計
```
ユーザー: "直径100mmのフランジを設計して"
LLM: create_object → パラメトリック円形フランジ生成
```

### 2D図面からの3D化
```
ユーザー: [2D図面画像] + "この図面から3Dモデルを作成"
LLM: 画像解析 → create_object(複数) → 組み立て
```

### おもちゃの車設計
```
ユーザー: "子供用のおもちゃの車を設計"
LLM: insert_part_from_library → edit_object → 組み合わせ
```

## LLMとCADの連携パターン

### 1. 自然言語→CADコマンド変換
```python
def interpret_design_request(user_input: str) -> List[CADCommand]:
    """自然言語をCADコマンドシーケンスに変換"""
    # LLMが設計意図を理解
    # 適切なtools呼び出しシーケンス生成
    return [
        create_object("Box", {length: 10, width: 5, height: 3}),
        edit_object("Box001", {position: [0, 0, 5]})
    ]
```

### 2. パラメトリック設計支援
```python
def parametric_design(constraints: Dict) -> FreeCADModel:
    """制約条件からパラメトリックモデル生成"""
    # 工学的制約の理解
    # 最適化されたジオメトリ生成
    # フィーチャーベースモデリング
```

### 3. 視覚フィードバックループ
```python
async def design_iteration():
    """設計→確認→修正のループ"""
    model = create_object(...)
    screenshot = get_view()
    feedback = llm_analyze_design(screenshot)
    if not feedback.is_satisfactory:
        edit_object(model, feedback.suggestions)
```

## 本研究での検討点

### Function Callingの利点
- **直接統合**: MCPサーバー不要の簡素なアーキテクチャ
- **高速応答**: 中間プロトコルなしの直接API呼び出し
- **柔軟性**: LLMの推論能力を活用したパラメータ最適化

### EVO.SHIP特化の設計考慮
- **造船特有の制約**: 浮力、安定性、構造強度
- **パラメトリック船体**: 主要寸法からの自動生成
- **部品ライブラリ**: 標準的な船舶部品の活用

## 今後の実装方針

### 1. ツール関数の段階的実装
```python
# Phase 1: 基本図形生成
create_hull_basic()
create_deck_structure()

# Phase 2: 詳細設計
add_bulkheads()
create_superstructure()

# Phase 3: 組み立て・検証
assemble_ship()
validate_design()
```

### 2. 自然言語インターフェース
- 専門用語の自動認識
- 曖昧な指示の明確化
- 設計意図の推論と提案

### 3. 品質保証機能
- 設計ルールチェック
- 工学的妥当性検証
- 過去設計との比較・改善提案

## 設計哲学の参考点

FreeCADMCPから学べる重要な設計原則：

### ツール設計の原則
1. **最小単位の操作**: 複雑な操作を基本要素に分解
2. **再利用性**: 異なる設計で共通利用可能
3. **組み合わせ性**: 複数ツールの連携による高度な機能

### エラー処理とフィードバック
- 操作失敗時の適切な状態復旧
- 視覚的な結果確認機能
- 段階的な修正・改善プロセス

この手法により、MCPを使用せずとも、LLMのFunction Calling機能を活用してEVO.SHIPとの効果的な連携が実現できると考えられます。

# Geminiを使用したモデル生成

